{"task_id": "./human-eval-bia/hello_world.ipynb", "prompt": "def return_hello_world():\n    \"\"\"\n    Returns the string \"hello world\".\n    \"\"\"", "canonical_solution": "\n    return \"hello world\"", "entry_point": "return_hello_world", "test": "def check(candidate):\n    assert candidate() == \"hello world\""}
{"task_id": "./human-eval-bia/label_processing_0.ipynb", "prompt": "def remove_labels_on_edges(label_image):\n    \"\"\"\n    Takes a label_image and removes all objects which touch the image border.\n    \"\"\"", "canonical_solution": "\n    import skimage\n    return skimage.segmentation.clear_border(label_image)", "entry_point": "remove_labels_on_edges", "test": "def check(candidate):\n    import numpy as np\n    \n    result = candidate(np.asarray([\n        [0,0,0,0,0],\n        [1,2,2,0,0],\n        [1,2,2,0,0],\n        [1,0,0,3,0],\n        [0,0,0,4,0],\n    ]))\n\n    # -1 becaue background counts\n    assert len(np.unique(result)) - 1 == 2\n    assert result.shape[0] == 5\n    assert result.shape[1] == 5"}
{"task_id": "./human-eval-bia/label_processing_1.ipynb", "prompt": "def label_sequentially(label_image):\n    \"\"\"\n    Takes a label_image with n labels and relabels the objects, \n    to make sure all integer labels between 0 and n are used. \n    No gaps are there.\n    \"\"\"", "canonical_solution": "\n    import skimage\n    return skimage.segmentation.relabel_sequential(label_image)[0]", "entry_point": "label_sequentially", "test": "def check(candidate):\n    import numpy as np\n    \n    result = candidate(np.asarray([\n        [0,1,0,0,0],\n        [0,0,0,0,0],\n        [0,4,0,0,0],\n        [0,0,5,0,0],\n        [0,0,0,6,0],\n    ])) \n\n    # -1 becaue background counts\n    assert len(np.unique(result)) - 1 == 4\n    assert result.max() == 4\n    assert result.shape[0] == 5\n    assert result.shape[1] == 5"}
{"task_id": "./human-eval-bia/measure_0.ipynb", "prompt": "def measure_intensity_of_labels(label_image, intensity_image):\n    \"\"\"\n    Takes a label image and an intensity image, and returns a list of mean intensities \n    of all pixels in the intensity image, belonging to a given label.\n    \"\"\"", "canonical_solution": "\n    import skimage\n    stats = skimage.measure.regionprops(label_image, intensity_image)\n    return [s.mean_intensity for s in stats]", "entry_point": "measure_intensity_of_labels", "test": "def check(candidate):\n    import numpy as np\n\n    label_image = np.asarray([\n        [0,1,0,0,0],\n        [0,0,0,0,0],\n        [0,2,2,2,2],\n        [0,3,3,0,0],\n        [0,0,0,4,0],\n    ])\n\n    intensity_image = np.asarray([\n        [0,2,0,0,0],\n        [0,0,0,0,0],\n        [0,3,3,4,4],\n        [0,3,3,0,0],\n        [0,0,0,5,0],\n    ])\n    \n    result = candidate(label_image, intensity_image) \n    assert np.array_equal([2,3.5,3,5], result)"}
{"task_id": "./human-eval-bia/measure_1.ipynb", "prompt": "def measure_pixel_count_of_labels(label_image):\n    \"\"\"\n    Takes a label image and returns a list of counts of number of pixels per label.\n    \"\"\"", "canonical_solution": "\n    import skimage\n    stats = skimage.measure.regionprops(label_image)\n    return [s.area for s in stats]", "entry_point": "measure_pixel_count_of_labels", "test": "def check(candidate):\n    import numpy as np\n    \n    result = candidate(np.asarray([\n        [0,1,0,0,0],\n        [0,0,0,0,0],\n        [0,2,2,2,0],\n        [0,3,3,0,0],\n        [0,0,0,4,0],\n    ])) \n    assert np.array_equal([1,3,2,1], result)"}
{"task_id": "./human-eval-bia/segmentation_0.ipynb", "prompt": "def label_binary_image_and_count_labels(binary_image):\n    \"\"\"\n    Consumes as input a binary image, applies connected component labeling to it, \n    counts the labeled objects and returns their count as single number.\n    \"\"\"", "canonical_solution": "\n    import skimage\n    import numpy as np\n    label_image = skimage.measure.label(binary_image)\n\n    return len(np.unique(label_image)) - 1", "entry_point": "label_binary_image_and_count_labels", "test": "def check(candidate):\n    import numpy as np\n    \n    assert candidate(np.asarray([\n        [0,0,0,0,0],\n        [0,1,0,0,0],\n        [0,0,0,0,0],\n        [1,0,0,0,0],\n        [0,0,0,1,0],\n    ])) == 3\n\n    assert candidate(np.asarray([\n        [0,0,0,0,0],\n        [0,1,0,0,0],\n        [0,0,0,0,0],\n        [0,0,0,0,0],\n        [0,0,0,0,0],\n    ])) == 1\n\n    assert candidate(np.asarray([\n        [0,0,0,0,0],\n        [0,0,0,0,0],\n        [0,0,0,0,0],\n        [0,0,0,0,0],\n        [0,0,0,0,0],\n    ])) == 0"}
{"task_id": "./human-eval-bia/segmentation_1.ipynb", "prompt": "def apply_otsu_threshold_and_count_postiive_pixels(image):\n    \"\"\"\n    Takes an image, applies Otsu's threshold method to it to create a binary image and \n    counts the positive pixels.\n    \"\"\"", "canonical_solution": "\n    import skimage\n    import numpy as np\n    binary_image = image > skimage.filters.threshold_otsu(image)\n\n    result = np.sum(binary_image)\n    print( result )\n    return result", "entry_point": "apply_otsu_threshold_and_count_postiive_pixels", "test": "def check(candidate):\n    import numpy as np\n    \n    assert candidate(np.asarray([\n        [0,0,0,0,0],\n        [1,1,1,0,0],\n        [1,1,1,0,0],\n        [1,0,0,0,0],\n        [0,0,0,1,0],\n    ])) == 8\n\n    assert candidate(np.asarray([\n        [0,0,0,0,0],\n        [0,1,0,0,0],\n        [1,2,1,0,0],\n        [0,1,3,4,0],\n        [0,1,4,1,0],\n    ])) == 4\n\n    assert candidate(np.asarray([\n        [0,0,0,0,0],\n        [0,0,0,0,0],\n        [0,0,0,0,0],\n        [0,0,0,0,0],\n        [0,0,0,0,0],\n    ])) == 0"}
